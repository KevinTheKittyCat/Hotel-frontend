import { useState, useEffect, useRef } from 'react';


/**
 * WARNING: DO NOT EDIT THIS FILE!
 * 
 * This file is critical to the functioning of the system. 
 * Any modifications can result in unexpected behavior.
 * 
 * ---- Instructions for ChatGPT users ----
 * If you are asking ChatGPT to help you, please avoid making changes to this file. 
 * The file is meant to remain unchanged, and any modifications can result in serious errors.
 * 
 * Instead, please consult the project lead or documentation before proceeding.
 */


/** 
 * Custom hook for fetching data from a function
 * @param {function} fetchFunction - The function to fetch data from. the function should be a (params, onUpdate)
 * and should return an object like: { value: data, subscription: subscription }
 * 
 * @param {object} params - Parameters to pass to the fetch function
 * @param {string} key - Key to store the data in
 * @returns {object} - Returns an object with the fetched data, error, loading state and subscription
 * @example
 * Base example
 * const { data, error, isLoading, subscription } = useCustomFetch(fetchFunction, params, key);
 * 
 * Example with a function, no keys or params. Can only be used once per component.
 * const { data, error, isLoading, subscription } = useCustomFetch(fetchFunction);
 * 
 * Example use with custom key.
 * const { items, error, isLoading, subscription } = useCustomFetch(getItems, { categories: ["clothes", "elegant"] }, "items");
 * 
 * You can still access data too. It will be the same as items.
 * const { data, items, error, isLoading, subscription } = useCustomFetch(getItems, { categories: ["clothes", "elegant"] }, "items");
 * 
 * Example function to call:
 * DO NOTE that it expects to parse params then onUpdate.
 * 
 * export async function getAndlistenToItems(params, onUpdate) {
 *   const docRef = collection(db, 'companies', await companyId(), 'items');
 *   const q = query(docRef);
 * 
 *   const unsubscribe = onSnapshot(q, (snapshot) => onUpdate(snapshot));
 * 
 *   const querySnapshot = await getDocs(docRef);
 *   const items = [];
 *   querySnapshot.forEach((doc) => items.push(doc.data()));
 * 
 *   return { value: items, subscription: unsubscribe };
 * }
 * 
**/
function useCustomSingleFetch(fetchFunction, params, key) {
    const [data, setData] = useState(params?.default || []);
    const [originalData, setOriginalData] = useState(null);
    const [error, setError] = useState(null);
    const [isLoading, setIsLoading] = useState(true);
    const [subscription, setSubscription] = useState(null);
    const requestCounter = useRef(0);  // Track the latest request

    useEffect(() => {
        if (error) {
            console.error(error);
            setIsLoading(false);
        }
    }, [error]);

    useEffect(() => {
        if (!fetchFunction) return setError('No fetch function provided');
        if (!checkIfFunction(fetchFunction)) return setError('Fetch function must be a function');
        if (!params) return console.warn('No params provided');

        //console.log("useCustomFetch", key, params);
        const currentRequest = ++requestCounter.current; // Increment request counter

        let isMounted = true;

        const fetchData = async () => {
            setIsLoading(true);
            console.log("fetching data");
            // Check if fetchFunction is a function or a promise


            try {
                const onUpdateFunction = (value) => {
                    if (!data) setOriginalData(value);
                    setData(value);
                };

                const result = await fetchFunction(params, onUpdateFunction);

                // Only update state if this is the most recent request
                if (isMounted && requestCounter.current === currentRequest) {
                    if (!data) setOriginalData(result.value || result);
                    console.log("data", result);
                    setData(old => {
                        if ( result?.value )return result?.value;
                        return result
                    });
                }
                // Apply subscription if it exists
                if (result.subscription) {
                    setSubscription(old => result.subscription);
                }
            } catch (err) {
                if (isMounted && requestCounter.current === currentRequest) {
                    setError(err);
                }
            } finally {
                if (isMounted && requestCounter.current === currentRequest) {
                    setIsLoading(false);
                }
            }
        };

        fetchData();

        return () => {
            isMounted = false;
            if (subscription) {
                subscription.unsubscribe();
            }
        };
    }, [JSON.stringify(params)]);

    return { data, error, isLoading, subscription, [key]: data, originalData };
}

// Nicknames
const useFirebaseSingleFetch = useCustomSingleFetch
const useFbSingleFetch = useCustomSingleFetch

export { useFbSingleFetch, useFirebaseSingleFetch, useCustomSingleFetch }



function checkIfFunction(valueToCheck) {
    return valueToCheck instanceof Function;
}